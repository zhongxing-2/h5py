#!/usr/bin/env python

#+
# 
# This file is part of h5py, a low-level Python interface to the HDF5 library.
# 
# Copyright (C) 2008 Andrew Collette
# http://h5py.alfven.org
# License: BSD  (See LICENSE.txt for full license)
# 
# $Date$
# 
#-

"""
    Setup script for the h5py package.  

    All commands take the usual distutils options, like --home, etc.  Pyrex is
    not required for installation, but will be invoked if the .c files are
    missing, one of the --pyrex options is used, or if a non-default API 
    version or debug level is requested.

    To build:
    python setup.py build

    To install:
    sudo python setup.py install

    To run the test suite locally (won't install anything):
    python setup.py test

    Additional options (for all modes):
        --pyrex         Have Pyrex recompile changed pyx files.
        --pyrex-only    Have Pyrex recompile changed pyx files, and stop.
        --pyrex-force   Recompile all pyx files, regardless of timestamps.
        --no-pyrex      Don't run Pyrex, no matter what

        --hdf5=path     Use alternate HDF5 directory (contains bin, include, lib)
        --api=<n>       Specifies API version.  Only "16" is currently useful.
        --debug=<n>     If nonzero, compile in debug mode.  The number is
                        interpreted as a logging-module level number.

    Advanced developer options:
    python setup.py dev [--doc] [--clean] [--readme=<name.html>]
        --doc:      Rebuild HTML documentation (requires epydoc)
        --clean:    Wipe out build/ and Pyrex-created .c, .dep files
        --readme:   Compile the RST readme file into an HTML fragment
"""

# === Global constants ========================================================

NAME = 'h5py'
VERSION = '0.2.2'

MIN_PYREX = '0.9.8.4'  # for compile_multiple
MIN_NUMPY = '1.0.3'

# === Initial imports and utilities ===========================================

from distutils.cmd import Command
from distutils.errors import DistutilsError, DistutilsExecError
from distutils.core import setup
from distutils.extension import Extension
import os
import sys
import shutil
import os.path as op

def fatal(instring, code=1):
    print >> sys.stderr, "Fatal: "+instring
    exit(code)

def warn(instring):
    print >> sys.stderr, "Warning: "+instring

# === Parse command line arguments ============================================

class CmdOptions(object):
    pass
opts = CmdOptions()

opts.AUTO_HDR = "# This file is automatically generated.  Do not edit."
opts.VERSION = VERSION
opts.ENABLE_PYREX = False        # Flag: Pyrex must be run
opts.PYREX_ONLY = False          # Flag: Run Pyrex, but don't perform build
opts.PYREX_FORCE = False         # Flag: Disable Pyrex timestamp checking
opts.PYREX_FORCE_OFF = False     # Flag: Don't run Pyrex, no matter what

opts.API_MAJ = 1                 # API interface version (not library version)
opts.API_MIN = 6
opts.DEBUG_LEVEL = 0             # Logging-module number, 0 to turn off
opts.HDF5_DIR = None             # Custom HDF5 directory, or None
opts.IO_NONBLOCK = False         # Experimental non-blocking I/O

for arg in sys.argv[:]:
    if arg == '--pyrex':
        opts.ENABLE_PYREX = True
        sys.argv.remove(arg)
    elif arg == '--pyrex-only':
        opts.ENABLE_PYREX = True
        opts.PYREX_ONLY = True
        sys.argv.remove(arg)
    elif arg == '--pyrex-force':
        opts.ENABLE_PYREX=True
        opts.PYREX_FORCE = True
        sys.argv.remove(arg)
    elif arg == '--no-pyrex':
        opts.PYREX_FORCE_OFF = True
        sys.argv.remove(arg)
    elif arg.find('--api=') == 0:
        opts.ENABLE_PYREX=True
        api = arg[6:]
        if api == '16':
            opts.API_MAJ = 1
            opts.API_MIN = 6
        elif api == '18':
            opts.API_MAJ = 1
            opts.API_MIN = 8
            warn('1.8.X API is still under development')
        else:
            fatal('Unrecognized API version "%s" (only "16", "18" currently allowed)' % api)
        sys.argv.remove(arg)
    elif arg.find('--debug=') == 0:
        opts.ENABLE_PYREX=True
        try:
            opts.DEBUG_LEVEL = int(arg[8:])
        except:
            fatal('Debuglevel not understood (wants --debug=<n>)')
        sys.argv.remove(arg)
    elif arg.find('--hdf5=') == 0:
        splitarg = arg.split('=',1)
        if len(splitarg) != 2:
            fatal("HDF5 directory not understood (wants --hdf5=/path/to/hdf5)")
        opts.HDF5_DIR = splitarg[1]
        sys.argv.remove(arg)
    elif arg.find('--io-nonblock') == 0:
        opts.ENABLE_PYREX=True
        opts.IO_NONBLOCK = True
        sys.argv.remove(arg)

if 'sdist' in sys.argv and os.path.exists('MANIFEST'):
    warn("Cleaning up stale MANIFEST file")
    os.remove('MANIFEST')

# === Required imports ========================================================

# Check Python version (2.5 or greater required)
if not (sys.version_info[0] == 2 and sys.version_info[1] >= 5):
    fatal("At least Python 2.5 is required to install h5py")

# Check for Numpy (required)
try:
    import numpy
    if numpy.version.version < MIN_NUMPY:
        fatal("Numpy version %s is out of date (>= %s needed)" % (numpy.version.version, MIN_NUMPY))

except ImportError:
    fatal("Numpy not installed (version >= %s required)" % MIN_NUMPY)
        
# === Platform configuration & Pyrex check ====================================

# Pyrex modules (without extension)
modules = ['h5' , 'h5f', 'h5g', 'h5s', 'h5t', 'h5d',
           'h5a', 'h5p', 'h5z', 'h5i', 'h5r', 'h5fd', 'utils']

# C source files required for Pyrex code (with extension)
extra_src = ['utils_low.c']    

# Where these live, relative to setup.py
src_path = 'h5py'

# Platform-dependent arguments to setup()
if os.name == 'nt':

    if opts.HDF5_DIR is None:
        fatal("On Windows, HDF5 directory must be specified.")

    libraries = ['hdf5dll']
    include_dirs = [numpy.get_include(), op.join(opts.HDF5_DIR, 'include')]
    library_dirs = [op.join(opts.HDF5_DIR, 'dll2')]  # Must contain only "hdf5dll.dll.a"
    runtime_dirs = []
    extra_compile_args = ['-DH5_USE_16_API', '-D_HDF5USEDLL_', '-DH5_SIZEOF_SSIZE_T=4']
    extra_link_args = []

else:

    libraries = ['hdf5']
    if opts.HDF5_DIR is None:
        include_dirs = [numpy.get_include(), '/usr/include', '/usr/local/include']
        library_dirs = ['/usr/lib/', '/usr/local/lib']
    else:
        include_dirs = [numpy.get_include(), op.join(opts.HDF5_DIR, 'include')]
        library_dirs = [op.join(opts.HDF5_DIR, 'lib')]
    runtime_dirs = library_dirs
    extra_compile_args = ['-DH5_USE_16_API', '-Wno-unused', '-Wno-uninitialized']
    extra_link_args = []

# If for some reason the .c files are missing, Pyrex is required.
cfiles = [op.join(src_path, x+'.c') for x in modules]

if not all( [op.exists(x) for x in cfiles]):
    opts.ENABLE_PYREX = True

if opts.ENABLE_PYREX and not opts.PYREX_FORCE_OFF:
    print "Running Pyrex..."

    try:
        from Pyrex.Compiler.Main import Version

        if Version.version >= MIN_PYREX:
            from Pyrex.Compiler.Main import compile_multiple, CompilationOptions

            # Check if the conditions.pxi file is up-to-date
            cond_path = op.join(src_path, 'conditions.pxi')
            cond = \
"""
%(AUTO_HDR)s

DEF H5PY_VERSION = "%(VERSION)s"
DEF H5PY_API_MAJ = %(API_MAJ)d
DEF H5PY_API_MIN = %(API_MIN)d
DEF H5PY_DEBUG = %(DEBUG_LEVEL)d

DEF H5PY_16API = H5PY_API_MIN == 6
DEF H5PY_18API = H5PY_API_MIN == 8

DEF H5PY_NONBLOCK = %(IO_NONBLOCK)d
""" \
            % opts.__dict__
            try:
                cond_file = open(cond_path,'r')
                cond_present = cond_file.read()
                cond_file.close()
            except IOError:
                cond_present = ""

            # If we regenerate the file every time, Pyrex's timestamp checking
            # is useless.  So only replace it if it's out of date.
            if cond_present != cond:
                print "Replacing conditions file..."
                cond_file = open(cond_path,'w')
                cond_file.write(cond)
                cond_file.close()

            pyxopts = CompilationOptions(verbose=True, timestamps=(not opts.PYREX_FORCE))
            results = compile_multiple( [op.join(src_path,x+'.pyx') for x in modules], pyxopts)

            if results.num_errors != 0:
                fatal("%d Pyrex compilation errors encountered; aborting." % results.num_errors)
            if opts.PYREX_ONLY:
                exit(0)
        else:
            fatal("Old Pyrex version %s detected (min %s)" % (Version.version, MIN_PYREX))

    except ImportError:
        fatal("Pyrex recompilation required, but Pyrex not installed.")
else:
    print "Skipping Pyrex..."

# One extension is built for each module
extensions = []
for module in modules:
    mod_sources  = [op.join(src_path, module) +'.c']
    mod_sources += [op.join(src_path, x) for x in extra_src]

    extensions.append(
        Extension( 
            NAME+'.'+module,
            mod_sources, 
            include_dirs = include_dirs, 
            libraries = libraries,
            library_dirs = library_dirs,
            runtime_library_dirs = runtime_dirs,
            extra_compile_args = extra_compile_args,
            extra_link_args = extra_link_args
        )
    )

# === Custom extensions for distutils =========================================

class test(Command):
    description = "Build %s and run unit tests" % NAME
    user_options = [('sections=','s','Comma separated list of tests ("-" prefix to NOT run)')]

    def initialize_options(self):
        self.sections = None

    def finalize_options(self):
        pass

    def run(self):
        buildobj = self.distribution.get_command_obj('build')
        buildobj.run()
        oldpath = sys.path
        try:
            sys.path = [op.abspath(buildobj.build_lib)] + oldpath
            import h5py.tests
            if not h5py.tests.runtests(None if self.sections is None else tuple(self.sections.split(','))):
                raise DistutilsError("Unit tests failed.")
        finally:
            sys.path = oldpath

class dev(Command):

    description = "Developer commands (--doc, --clean, --readme=<file>)"
    user_options = [('doc','d','Rebuild documentation'),
                    ('readme=','r','Compile HTML file from README.txt'),
                    ('clean', 'c', 'Remove built files and Pyrex temp files.')]
    boolean_options = ['doc']

    def initialize_options(self):
        self.doc = False
        self.readme = False
        self.clean = False

    def finalize_options(self):
        pass

    def run(self):
        if self.clean:
            for x in ('build','docs/api-html', 'docs/manual-html'):
                try:
                    shutil.rmtree(x)
                except OSError:
                    pass
            fnames = [ op.join(src_path, x+'.dep') for x in modules ] + \
                     [ op.join(src_path, x+'.c') for x in modules ] + \
                     [ 'MANIFEST']

            for name in fnames:
                try:
                    os.remove(name)
                except OSError:
                    pass

        if self.doc:
            buildobj = self.distribution.get_command_obj('build')
            buildobj.run()
            for x in ('docs', 'docs/api-html'):
                if not op.exists(x):
                    os.mkdir(x, 0755)

            retval = os.spawnlp(os.P_WAIT, 'epydoc', '-q', '--html',
                        '-o', 'docs/api-html', '--config', 'docs.cfg', 
                        os.path.join(buildobj.build_lib, NAME) )
            if retval != 0:
                warn("Could not run epydoc to build documentation.")


            retval = os.system("cd docs; make html")
            if retval != 0:
                warn("Could not run Sphinx doc generator")
            else:
                shutil.copytree('docs/build/html', 'docs/manual-html')

        if self.readme:
            import docutils.core
            fh = open('README.txt','r')
            parts = docutils.core.publish_parts(fh.read(),writer_name='html')
            fh.close()
            fh = open(self.readme,'w')
            fh.write(parts['body'])
            fh.close()

# New commands for setup (e.g. "python setup.py test")
if os.name == 'nt':
    CMD_CLASS = {'test': test}
else:
    CMD_CLASS = {'dev': dev, 'test': test}

#print "Configuration"
#print '-'*40
#for key in sorted(opts.__dict__):
#    print "%-20s %s" % (key, opts.__dict__[key])

# Run setup
setup(
  name = NAME,
  version = VERSION,
  author = 'Andrew Collette',
  url = 'h5py.alfven.org',
  packages = ['h5py','h5py.tests'],
  package_data = {'h5py': ['*.pyx'],  # so source is available for tracebacks
                  'h5py.tests': ['data/*.hdf5']},  # Should be / even on Windows
  ext_modules = extensions,
  requires = ['numpy (>=1.0.3)'],
  provides = ['h5py'],
  cmdclass = CMD_CLASS
)



