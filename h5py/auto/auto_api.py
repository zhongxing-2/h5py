
import re



class BadLineError(Exception):
    pass

class UnknownCodeError(Exception):
    pass


# The following files are used to talk to the HDF5 api:
#
# (1) hdf5.pxd:         HDF5 function signatures    (autogenerated)
# (2) hdf5_types.pxd:   HDF5 type definitions       (static)
# (3) defs.pxd:         HDF5 function proxy defs    (autogenerated)
# (4) defs.pyx:         HDF5 function proxies       (autogenerated)

function_pattern = r'(?P<code>(unsigned[ ]+)?[a-zA-Z_]+[a-zA-Z0-9_]*\**)[ ]+(?P<fname>[a-zA-Z_]+[a-zA-Z0-9_]*)[ ]*\((?P<sig>[a-zA-Z0-9_,* ]*)\)([ ]+(?P<api>([0-9]\.[0-9])))?'
sig_pattern = r'(unsigned[ ]+)?(?:[a-zA-Z_]+[a-zA-Z0-9_]*\**)[ ]+[ *]*(?P<param>[a-zA-Z_]+[a-zA-Z0-9_]*)'

fp = re.compile(function_pattern)
sp = re.compile(sig_pattern)

raw_preamble = """\
include "context.pxi"
from hdf5_types cimport *
from external_types cimport *

"""

def_preamble = """\
include "context.pxi"
from hdf5_types cimport *
from external_types cimport *

"""

imp_preamble = """\
include "context.pxi"
from hdf5_types cimport *
from external_types cimport *

cimport hdf5

cdef int set_exception():
    return 1

"""

class FunctionCruncher2(object):

    def __init__(self):
        pass

    def run(self):

        # Function definitions file
        self.functions = open('auto_functions.txt','r')

        # Create output files
        self.raw_defs =     open('hdf5.pxd','w')
        self.cython_def =   open('defs.pxd','w')
        self.cython_imp =   open('defs.pyx','w')

        self.raw_defs.write(raw_preamble)
        self.cython_def.write(def_preamble)
        self.cython_imp.write(imp_preamble)

        self.raw_defs.write('cdef extern from "hdf5.h":\n')

        for line in self.functions:
            line = line.strip()
            if not line or line[0] == '#':
                continue
            try:
                self.handle_line(line)
            except BadLineError:
                print "Skipped <<%s>>" % line

        self.functions.close()
        self.cython_imp.close()
        self.cython_def.close()
        self.raw_defs.close()

    def handle_line(self, line):
        """ Parse a function definition line and output the correct code
        to each of the output files. """

        m = fp.match(line)
        if m is None:
            raise BadLineError("Signature for line <<%s>> did not match regexp" % line)
        function_parts = m.groupdict()

        self.raw_defs.write('  '+self.make_raw_sig(function_parts))
        self.cython_def.write(self.make_cython_sig(function_parts))
        self.cython_imp.write(self.make_cython_imp(function_parts))

    def make_raw_sig(self, function_parts):
        """ Build a "cdef extern"-style definition for an HDF5 function """

        return "%(code)s %(fname)s(%(sig)s)\n" % function_parts

    def make_cython_sig(self, function_parts):
        """ Build Cython signature for wrapper function """

        return "cdef %(code)s %(fname)s(%(sig)s) except *\n" % function_parts

    def make_cython_imp(self, function_parts):
        """ Build a Cython wrapper implementation """

        args = sp.findall(function_parts['sig'])
        if args is None:
            raise BadLineError("Can't understand function signature <<%s>>" % function_parts['sig'])
        args = ", ".join(x[1] for x in args)

        # Figure out what conditional to use for the error testing
        code = function_parts['code']
        if '*' in code or code in ('H5T_conv_t',):
            condition = "==NULL"
            retval = "NULL"
        elif code in ('int', 'herr_t', 'htri_t', 'hid_t','hssize_t','ssize_t') \
          or re.match(r'H5[A-Z]+_[a-zA-Z_]+_t',code):
            condition = "<0"
            retval = "-1"
        elif code in ('unsigned int','haddr_t','hsize_t','size_t'):
            condition = "==0"
            retval = 0
        else:
            raise UnknownCodeError("Return code <<%s>> unknown" % self.code)

        parts = function_parts.copy()
        parts.update({'condition': condition, 'retval': retval, 'args': args})

        # Have to use except * because Cython can't handle special types here
        imp = """\
cdef %(code)s %(fname)s(%(sig)s) except *:
    cdef %(code)s r
    r = hdf5.%(fname)s(%(args)s)
    if r%(condition)s:
        if set_exception():
            return <%(code)s>%(retval)s;
    return r

"""
        return imp % parts


if __name__ == '__main__':

    fc = FunctionCruncher2()
    fc.run()



